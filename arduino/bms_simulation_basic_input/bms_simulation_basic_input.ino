#include <SoftwareSerial.h>

#define RX 3
#define TX 5

uint8_t input_buffer[10] = {0};
uint8_t output_buffer[37] = {0};

// uint8_t input_03[7] = {0xdd, 0xa5, 0x03, 0x00, 0xff, 0xfd, 0x77};
// uint8_t input_04[7] = {0xdd, 0xa5, 0x04, 0x00, 0xff, 0xfc, 0x77};
uint8_t output_03_1[36] = {0xdd, 0x03, 0x00, 0x1d, 0x12, 0x6a, 0x00, 0x00, 0x08,
 0x97, 0x13, 0x88, 0x00, 0x00, 0x2d, 0x53, 0x00, 0x00, 0x00 ,0x00, 0x00, 0x00, 
 0x22, 0x2c, 0x01, 0x0D, 0x03, 0x0b, 0xb4, 0x0b, 0xa8, 0x0b, 0xa0, 0xfb, 0x31, 
 0x77};
uint8_t output_04_1[37] = {0xDD, 0x04, 0x00, 0x1E, 0x0F, 0x66, 0x0F, 0x63, 0x0F,
  0x63, 0x0F, 0x64, 0x0F, 0x3E, 0x0F, 0x63, 0x0F, 0x37, 0x0F, 0x5B, 0x0F, 0x65, 
  0x0F, 0x3B, 0x0F, 0x63, 0x0F, 0x63, 0x0F, 0x3C, 0x0F, 0x66, 0x0F, 0x3D, 0xF9, 
  0xF9, 0x77};
uint8_t output_03_2[36] = {0xdd, 0x03, 0x00, 0x1d, 0x12, 0x3e, 0x00, 0x00, 0x08, 
  0x68, 0x13, 0x88, 0x00, 0x00, 0x2d, 0x53, 0x00, 0x00, 0x00 ,0x00, 0x00, 0x00, 
  0x22, 0x2c, 0x01, 0x0D, 0x03, 0x0b, 0xb2, 0x0b, 0xab, 0x0b, 0xa0, 0xfb, 0x8b, 
  0x77};
uint8_t output_04_2[37] = {0xDD, 0x04, 0x00, 0x1E, 0x0F, 0x66, 0x0F, 0x58, 0x0F, 
  0x3F, 0x0F, 0x62, 0x0F, 0x5B, 0x0F, 0x63, 0x0F, 0x37, 0x0F, 0x5B, 0x0F, 0x65, 
  0x0F, 0x3B, 0x0F, 0x63, 0x0F, 0x63, 0x0F, 0x3C, 0x0F, 0x66, 0x0F, 0x3D, 0xfa, 
  0x0d, 0x77};

uint8_t available_registers[55] = {0x00, 0x01, 0x03, 0x04, 0x05, 0x10, 0x11, 
  0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 
  0x1f, 0x20, 
  0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2e, 0x32, 
  0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 
  0xa0, 0xa1, 0xa2, 0xaa, 0xe1, 0xe2};
uint8_t registers_sizes[55] = {2, 2, 29, 30, 12, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 12, 12, 12, 22, 2, 2};
uint8_t sizes_prefix_sums[55] = {0};
uint8_t registers_values_buffer[227] = { // 183
  0x00, 0x00, // 0x00 
  0x00, 0x00, // 0x01
  0x12, 0x6a, 0x00, 0x00, 0x08, 0x97, 0x13, 0x88, 0x00, 0x00, 0x2d, 0x53, 0x00, 
    0x00, 0x00 ,0x00, 0x00, 0x00, 0x22, 0x2c, 0x01, 0x0D, 0x03, 0x0b, 0xb4, 
    0x0b, 0xa8, 0x0b, 0xa0, // 0x03 29
  0x0F, 0x66, 0x0F, 0x63, 0x0F, 0x63, 0x0F, 0x64, 0x0F, 0x3E, 0x0F, 0x63, 0x0F, 
    0x37, 0x0F, 0x5B, 0x0F, 0x65, 0x0F, 0x3B, 0x0F, 0x63, 0x0F, 0x63, 0x0F, 
    0x3C, 0x0F, 0x66, 0x0F, 0x3D, // 0x04 30
  0x04, 0x61, 0x62, 0x63, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x05 12
  0x13, 0x88, //0x10
  0x0f, 0xa0, //0x11
  0x15, 0x18, //0x12
  0x11, 0x30, //0x13
  0x00, 0x14, //0x14
  0x31, 0x1c, //0x15 manufacture date 28.08.2024
  0x04, 0xd2, //0x16 serial number
  0x01, 0xa3, //0x17
  0x0b, 0xb4, //0x18
  0x0b, 0xc3, //0x19
  0x0b, 0xc8, //0x1a
  0x0b, 0xb8, //0x1b
  0x0b, 0xcc, //0x1c
  0x0b, 0xd1, //0x1d
  0x0b, 0xb2, //0x1e
  0x0b, 0xa4, //0x1f
  0x15, 0xe0, //0x20 shutdown voltage from above
  0x15, 0x4a, //0x21 return voltage from above
  0x10, 0x68, //0x22 shutdown voltage from beyond
  0x11, 0x62, //0x23 return voltage from beyond
  0x16, 0x44, //0x24 shutdown line voltage from above
  0x15, 0x7c, //0x25 return line voltage from above
  0x0f, 0xa0, //0x26 shutdown line voltage from beyond
  0x10, 0xcc, //0x27 return line voltage from beyond
  0x17, 0x70, //0x28 charge current threshold
  0x17, 0xd4, //0x29 discharge current threshold
  0x0d, 0xac, //0x2a balanced lines' voltage
  0x00, 0x14, //0x2b balance window
  0x00, 0x1c, //0x2c
  0x00, 0x07, //0x2e thermoresistors' state
  0x14, 0x50, //0x32
  0x13, 0x88, //0x33
  0x12, 0xc0, //0x34
  0x11, 0xf8, //0x35
  0x13, 0x88, //0x36
  0x13, 0x77, //0x37
  0x00, 0x23, //0x38
  0b00110000, 0x01, //0x39
  0x01, 0x02, //0x3a
  0x03, 0x04, //0x3b
  0x05, 0x06, //0x3c
  0x07, 0x08, //0x3d
  0x09, 0x0a, //0x3e
  0x0b, 0x0c, //0x3f
  0x04, 0x61, 0x62, 0x63, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xa0 12
  0x04, 0x61, 0x62, 0x63, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xa1 12
  0x04, 0x61, 0x62, 0x63, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xa2 12
  0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 
    0x07, 0x00, 0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x0c, //0xaa 22
  0x00, 0x00, //0xe1
  0x00, 0x00, //0xe2
};

SoftwareSerial swSerial(RX, TX);
bool output_03_flag = false;
bool output_04_flag = false;

uint64_t randomValue = 0;
uint64_t a = 106;
uint64_t c = 1283;
uint64_t m = 6075;

uint64_t get_random_number()
{
  randomValue = (a * randomValue + c) % m;
  return randomValue;
}

void randomize_uint16_t(uint8_t* high, int dist)
{
  int16_t diff = get_random_number() % (2 * dist + 1) - dist;
  /* arduino uno has little endian CPU!
  uint16_t value_ = *reinterpret_cast<uint16_t*>(high);
  is UB, because is violates strict aliasing rule
  The rule forbids pointer casts except of:
  - int* <-> unsigned*
  - int* -> cv int*\cv unsigned*
  - int* -> char*\uint8_t*\int8_t* (not in the opposite direction)
  - int* -> AggregrateType* (<-?), where
  struct AggregrateType
  {
    int x;
  };
  The reason is that compiler may optimize such code incorrectly:
  int f(int* pi, float* pf)
  {
    *pi = 1;
    *pf = 2;
    return *pi;
  } 

  int main()
  {
    int i = 5;
    return f(&i, reinterpret_cast<float*>(&i));
  }
  Main may return 1, because compiler may compile it the following way:
  mov dword ptr[register1] 1
  mov dword ptr[register2] 2
  mov eax 1 // compiler does not see that pointers are the same and 
  // optimizes incorrectly
  */
  uint16_t value_ = (static_cast<uint16_t>(*high) << 8) + 
    + *(high + 1);
  value_ += diff;
  *high = static_cast<uint8_t>(value_ >> 8);
  *(high + 1) = static_cast<uint8_t>(value_);
}

int register_binary_search(uint8_t value, uint8_t* registers, uint8_t sz)
{
  if (value < registers[0] || value > registers[sz - 1]) return -1;
  if (value == registers[0]) return 0;
  if (value == registers[sz - 1]) return sz - 1;
  uint8_t left = 0;
  uint8_t right = sz - 1;
  while (right - left > 1)
  {
      uint8_t middle = (right + left) / 2;
      if (value == registers[middle]) return middle;
      if (value > registers[middle]) left = middle;
      else right = middle;
  }
  return -1;
}

void set_crc(uint8_t* begin, uint8_t* end, uint8_t* crc_buffer)
{
  uint16_t crc = 0x10000;
  for (uint8_t* p_tmp = begin; p_tmp <= end; ++p_tmp) crc -= *p_tmp;
  crc_buffer[0] = crc >> 8;
  crc_buffer[1] = crc;
}

void setup() {
  swSerial.begin(9600);
  Serial.begin(9600);
  for (int i = 1; i < sizeof(sizes_prefix_sums); ++i)
  {
    sizes_prefix_sums[i] = sizes_prefix_sums[i - 1] + registers_sizes[i - 1];
  }
  while (!swSerial);
  while (!Serial);
  swSerial.listen();
  Serial.print("initialized\n");
}

void loop()
{
  if (!swSerial.available()) return;
  uint64_t current_time = millis();
  randomValue = millis();
  while (millis() - current_time < 70);
  int i = 0;
  Serial.print("Received: ");
  for (; swSerial.available(); ++i)
  {
    input_buffer[i] = swSerial.read();
    Serial.print(input_buffer[i], HEX);
    Serial.print(' ');
  }
  // проверка dd, 77, crc TO DO
  uint8_t register_ = register_binary_search(input_buffer[2], 
    reinterpret_cast<uint8_t*>(available_registers), 
    sizeof(available_registers));
  uint8_t message_size = 7;
  if (register_ < 0) // регистр не найден
  {
    // сообщение об ошибке dd p-p 80 00 crc 
    uint8_t error_message[7] = {0xdd, 0x00, 0x80, 0x00, 0x00, 0x00, 0x77};
    error_message[1] = register_;
    set_crc(error_message + 3, error_message + 3, error_message + 4);
    strcpy(output_buffer, error_message); // мб поменять src и dest
  } else { // регистр найден
    // сообщение с содержимым регистра
    if (input_buffer[1] == 0xa5) // reading
    {
      Serial.println("reading");
      // Serial.print(voltage_, HEX);
      message_size = registers_sizes[register_] + 7;
      uint8_t message[message_size] = {0};
      message[0] = 0xdd;
      message[1] = available_registers[register_];
      message[3] = registers_sizes[register_];
      memcpy(message + 4, &registers_values_buffer[sizes_prefix_sums[register_]], 
        registers_sizes[register_]);
      set_crc(message + 3, message + message_size - 4, 
        message + message_size - 3);
      message[message_size - 1] = 0x77;
      memcpy(output_buffer, message, message_size);
    } else { // writing
      Serial.println("writing");
      output_buffer[0] = 0xdd;
      output_buffer[1] = register_;
      output_buffer[6] = 0x77;
      switch (register_)
      {
        case 0xe1:
          registers_values_buffer[24] = input_buffer[5];
        break;
      }
    }
  }
  // отправка сообщения
  Serial.print("Sent: ");
  for (int i = 0; i < message_size; ++i) 
  {
    swSerial.write(output_buffer[i]);
    Serial.print(output_buffer[i], HEX);
    Serial.print(' ');
  }
  Serial.println();
  memset(input_buffer, 0, sizeof(input_buffer));
  memset(output_buffer, 0, sizeof(output_buffer));
  // рандомизация 0x03 и 0x04
  randomize_uint16_t(registers_values_buffer + 4, 10);
  randomize_uint16_t(registers_values_buffer + 6, 4);
  randomize_uint16_t(registers_values_buffer + 8, 6);
  uint16_t currentCharge = (registers_values_buffer[8] << 8) + 
    registers_values_buffer[9];
  uint16_t fullCharge = (registers_values_buffer[10] << 8) + 
    registers_values_buffer[11];
  registers_values_buffer[23] = static_cast<uint8_t>(
    static_cast<float>(currentCharge) * 100 / fullCharge);
  Serial.print(registers_values_buffer[23], HEX);
  for (int i = 0; i < 3; ++i)
  {
    randomize_uint16_t(registers_values_buffer + 27 + 2 * i, 2);
  }
  for (int i = 0; i < 13; ++i)
  {
    randomize_uint16_t(registers_values_buffer + 33 + 2 * i, 1);
  }
}
